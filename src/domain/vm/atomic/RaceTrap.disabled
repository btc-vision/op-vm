#![allow(clippy::single_match, clippy::too_many_lines)]

use std::fmt::{Debug, Formatter};
use std::sync::atomic::{AtomicU32, Ordering};

use wasmer::sys::{FunctionMiddleware, MiddlewareReaderState, ModuleMiddleware};
use wasmer::wasmparser::Operator;
use wasmer_types::{
    ExportIndex, FunctionType, GlobalInit, GlobalType, ImportKey, ImportType, LocalFunctionIndex,
    MemoryType, ModuleInfo, Mutability, Pages, Type,
};

const READ_HOOK: &str = "race_read";
const WRITE_HOOK: &str = "race_write";

#[derive(Default)]
pub struct RaceTrap {
    meta_mem: AtomicU32,
    clock_glob: AtomicU32,
    read_fn: AtomicU32,
    write_fn: AtomicU32,
}

impl Clone for RaceTrap {
    fn clone(&self) -> Self {
        use Ordering::Relaxed;
        Self {
            meta_mem: AtomicU32::new(self.meta_mem.load(Relaxed)),
            clock_glob: AtomicU32::new(self.clock_glob.load(Relaxed)),
            read_fn: AtomicU32::new(self.read_fn.load(Relaxed)),
            write_fn: AtomicU32::new(self.write_fn.load(Relaxed)),
        }
    }
}

impl Debug for RaceTrap {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("RaceTrap").finish()
    }
}

impl RaceTrap {
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }
}

impl ModuleMiddleware for RaceTrap {
    fn transform_module_info(
        &self,
        m: &mut ModuleInfo,
    ) -> Result<(), wasmer_types::MiddlewareError> {
        use Ordering::Relaxed;

        let meta_idx = m.memories.push(MemoryType {
            minimum: Pages(1),
            maximum: None,
            shared: false,
            memory64: false,
        });
        m.exports
            .insert("__race_meta".into(), ExportIndex::Memory(meta_idx));
        self.meta_mem.store(meta_idx.as_u32(), Relaxed);

        let clk_idx = m.globals.push(GlobalType::new(Type::I64, Mutability::Var));
        m.global_initializers.push(GlobalInit::I64Const(0));
        m.exports
            .insert("__race_clock".into(), ExportIndex::Global(clk_idx));
        self.clock_glob.store(clk_idx.as_u32(), Relaxed);

        let hook_sig = m
            .signatures
            .push(FunctionType::new(vec![Type::I32, Type::I32], vec![]));

        let read_key = ImportKey {
            module: "env".into(),
            field: READ_HOOK.into(),
            import_idx: 0,
        };
        m.imports
            .insert(read_key.clone(), ImportType::Function(hook_sig));
        let read_idx = m.imports.get_index_of(&read_key).unwrap() as u32;
        self.read_fn.store(read_idx, Relaxed);

        let write_key = ImportKey {
            module: "env".into(),
            field: WRITE_HOOK.into(),
        };
        m.imports
            .insert(write_key.clone(), ImportType::Function(hook_sig));
        let write_idx = m.imports.get_index_of(&write_key).unwrap() as u32;
        self.write_fn.store(write_idx, Relaxed);

        Ok(())
    }

    fn generate_function_middleware(&self, _: LocalFunctionIndex) -> Box<dyn FunctionMiddleware> {
        Box::new(FunctionRaceTrap::new(self))
    }
}

struct FunctionRaceTrap {
    meta_mem: u32,
    clock_glob: u32,
    read_fn: u32,
    write_fn: u32,

    tmp_addr: Option<u32>, 
    tmp_i32: Option<u32>,
    tmp_i64: Option<u32>,
    tmp_f32: Option<u32>,
    tmp_f64: Option<u32>,
}

impl FunctionRaceTrap {
    fn new(parent: &RaceTrap) -> Self {
        use Ordering::Relaxed;
        Self {
            meta_mem: parent.meta_mem.load(Relaxed),
            clock_glob: parent.clock_glob.load(Relaxed),
            read_fn: parent.read_fn.load(Relaxed),
            write_fn: parent.write_fn.load(Relaxed),
            tmp_addr: None,
            tmp_i32: None,
            tmp_i64: None,
            tmp_f32: None,
            tmp_f64: None,
        }
    }

    fn ensure_local(&mut self, ty: Type, state: &mut MiddlewareReaderState<'_>) -> u32 {
        let slot = match ty {
            Type::I32 => &mut self.tmp_i32,
            Type::I64 => &mut self.tmp_i64,
            Type::F32 => &mut self.tmp_f32,
            Type::F64 => &mut self.tmp_f64,
            _ => unreachable!(),
        };
        if let Some(idx) = *slot {
            return idx;
        }
        let idx = state.add_local(ty);
        *slot = Some(idx);
        idx
    }

    fn addr_local(&mut self, state: &mut MiddlewareReaderState<'_>) -> u32 {
        if let Some(i) = self.tmp_addr {
            return i;
        }
        let i = state.add_local(Type::I32);
        self.tmp_addr = Some(i);
        i
    }
}

impl Debug for FunctionRaceTrap {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FunctionRaceTrap").finish()
    }
}

impl FunctionMiddleware for FunctionRaceTrap {
    fn feed<'a>(
        &mut self,
        op: Operator<'a>,
        state: &mut MiddlewareReaderState<'a>,
    ) -> Result<(), wasmer_types::MiddlewareError> {
        use Operator::*;

        let push_sz = |st: &mut MiddlewareReaderState<'a>, n: u32| {
            st.push_operator(I32Const { value: n as i32 });
        };

        match op {

            I32Load { .. }
            | I32Load8S { .. }
            | I32Load8U { .. }
            | I32Load16S { .. }
            | I32Load16U { .. } => {
                let addr_tmp = self.addr_local(state);
                state.push_operator(LocalTee {
                    local_index: addr_tmp,
                });
                push_sz(state, load_size(&op));
                state.push_operator(Call {
                    function_index: self.read_fn,
                });
                state.push_operator(op);
            }
            I64Load { .. }
            | I64Load8S { .. }
            | I64Load8U { .. }
            | I64Load16S { .. }
            | I64Load16U { .. }
            | I64Load32S { .. }
            | I64Load32U { .. } => {
                let addr_tmp = self.addr_local(state);
                state.push_operator(LocalTee {
                    local_index: addr_tmp,
                });
                push_sz(state, load_size(&op));
                state.push_operator(Call {
                    function_index: self.read_fn,
                });
                state.push_operator(op);
            }
            F32Load { .. } | F64Load { .. } => {
                let addr_tmp = self.addr_local(state);
                state.push_operator(LocalTee {
                    local_index: addr_tmp,
                });
                push_sz(state, load_size(&op));
                state.push_operator(Call {
                    function_index: self.read_fn,
                });
                state.push_operator(op);
            }

            I32Store { .. } | I32Store8 { .. } | I32Store16 { .. } => {
                self.instrument_store(state, &op, Type::I32, store_size(&op));
            }
            I64Store { .. } | I64Store8 { .. } | I64Store16 { .. } | I64Store32 { .. } => {
                self.instrument_store(state, &op, Type::I64, store_size(&op));
            }
            F32Store { .. } => self.instrument_store(state, &op, Type::F32, 4),
            F64Store { .. } => self.instrument_store(state, &op, Type::F64, 8),

            _ => state.push_operator(op),
        }
        Ok(())
    }
}

impl FunctionRaceTrap {
    fn instrument_store<'a>(
        &mut self,
        state: &mut MiddlewareReaderState<'a>,
        op: &Operator<'a>,
        val_ty: Type,
        size_bytes: u32,
    ) {
        use Operator::*;

        let tmp_val = self.ensure_local(val_ty, state);
        let tmp_addr = self.addr_local(state);

        state.push_operator(LocalSet {
            local_index: tmp_val,
        });

        state.push_operator(LocalTee {
            local_index: tmp_addr,
        });

        state.push_operator(I32Const {
            value: size_bytes as i32,
        });
        state.push_operator(Call {
            function_index: self.write_fn,
        });

        state.push_operator(LocalGet {
            local_index: tmp_addr,
        });
        state.push_operator(LocalGet {
            local_index: tmp_val,
        });
        state.push_operator(op.clone());
    }
}

#[inline]
fn load_size(op: &Operator) -> u32 {
    use Operator::*;
    match *op {
        I32Load8S { .. } | I32Load8U { .. } | I64Load8S { .. } | I64Load8U { .. } => 1,
        I32Load16S { .. } | I32Load16U { .. } | I64Load16S { .. } | I64Load16U { .. } => 2,
        I64Load32S { .. } | I64Load32U { .. } => 4,
        I32Load { .. } | F32Load { .. } => 4,
        I64Load { .. } | F64Load { .. } => 8,
        _ => unreachable!(),
    }
}

#[inline]
fn store_size(op: &Operator) -> u32 {
    use Operator::*;
    match *op {
        I32Store8 { .. } | I64Store8 { .. } => 1,
        I32Store16 { .. } | I64Store16 { .. } => 2,
        I64Store32 { .. } => 4,
        I32Store { .. } | F32Store { .. } => 4,
        I64Store { .. } | F64Store { .. } => 8,
        _ => unreachable!(),
    }
}

use dashmap::DashMap;
use std::sync::atomic::AtomicU64;
use std::sync::{Mutex, MutexGuard};

type Epoch = u64; 

#[repr(C, align(16))]
struct MetaCell {
    re: AtomicU64, 
    we: AtomicU64, 
}

lazy_static::lazy_static! {
    static ref META: DashMap<u64, Mutex<MetaCell>> = DashMap::new();
    static ref THREAD_CLOCK: DashMap<u32, AtomicU64> = DashMap::new();
}

#[inline]
fn epoch(tid: u32, clk: u64) -> Epoch {
    ((tid as u64) << 32) | (clk & 0xFFFF_FFFF)
}

#[inline]
fn bump_clock(tid: u32) -> u64 {
    THREAD_CLOCK
        .entry(tid)
        .or_insert_with(|| AtomicU64::new(0))
        .fetch_add(1, Ordering::Relaxed)
        .wrapping_add(1)
}

pub fn race_read(addr: u32, len: u32) {
    let tid = current_tid();
    let clk = bump_clock(tid);
    let ep = epoch(tid, clk);
    for i in 0..len {
        let key = addr.wrapping_add(i) as u64;
        let cell = META.entry(key).or_insert_with(|| {
            Mutex::new(MetaCell {
                re: AtomicU64::new(0),
                we: AtomicU64::new(0),
            })
        });
        let mut g: MutexGuard<'_, MetaCell> = cell.lock().unwrap();
        let we = g.we.load(Ordering::Relaxed);
        if we != 0 && (we >> 32) != tid as u64 {
            unreachable!(); 
        }
        g.re.store(ep, Ordering::Relaxed);
    }
}

pub fn race_write(addr: u32, len: u32) {
    let tid = current_tid();
    let clk = bump_clock(tid);
    let ep = epoch(tid, clk);
    for i in 0..len {
        let key = addr.wrapping_add(i) as u64;
        let cell = META.entry(key).or_insert_with(|| {
            Mutex::new(MetaCell {
                re: AtomicU64::new(0),
                we: AtomicU64::new(0),
            })
        });
        let mut g = cell.lock().unwrap();
        let re = g.re.load(Ordering::Relaxed);
        let we = g.we.load(Ordering::Relaxed);
        if (re != 0 && (re >> 32) != tid as u64) || (we != 0 && (we >> 32) != tid as u64) {
            unreachable!(); 
        }
        g.we.store(ep, Ordering::Relaxed);
    }
}

#[inline]
fn current_tid() -> u32 {

    thread_local! { static TID: u32 = 0; }
    TID.with(|t| *t)
}